<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ICDE</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 10 Jan 2023 04:22:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>leetcode周赛笔记</title>
      <link>http://example.com/2023/01/09/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B0/</link>
      <guid>http://example.com/2023/01/09/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 08 Jan 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;单周赛&quot;&gt;311单周赛&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;时间：2022.09.18&lt;/p&gt;
&lt;p&gt;【过程】&lt;/p&gt;
&lt;p&gt;前两道题很快就写出来了&lt;/p&gt;
&lt;p&gt;第三道题，很难受，一种感觉能写出来但是就是写不出来的感觉，还是对于二叉树的递归不够深</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="单周赛">311单周赛</h2><blockquote><p>时间：2022.09.18</p><p>【过程】</p><p>前两道题很快就写出来了</p><p>第三道题，很难受，一种感觉能写出来但是就是写不出来的感觉，还是对于二叉树的递归不够深入</p><p>第四道题用常规方法写出来，但是超时...</p></blockquote><p>###6181. 最长的字母序连续子字符串的长度</p><blockquote><p><ahref="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/">题目</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比赛写的时候是用栈写的，但是其实只是用到栈的思想，不用栈也是完全可以的</span></span><br><span class="line"><span class="comment">// 抓住 1、连续 2、字母序 3、最大</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestContinuousSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>); <span class="comment">// 下一个需要的字符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c == need)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            need ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不满足的话，从这个位置重新开始向后寻找</span></span><br><span class="line">            need = c + <span class="number">1</span>;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(maxLen, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转二叉树的奇数层">6182. 反转二叉树的奇数层</h3><blockquote><p><ahref="https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/">题目</a></p></blockquote><p>【答题】</p><p>解题过程中，想过递归和队列两种方式。</p><p>但是，递归想的一直都是如何交换节点，所以很快就放弃了</p><p>使用队列，想的是在奇数层用遍历将值倒过来，写的过程中不是很顺利</p><p>【思路】</p><p><strong>核心思想就是交换值，不交换结点</strong></p><h4 id="dfs-递归">DFS 递归</h4><p>其实使用DFS递归的过程中只要交换结点的值就可以了，这样就不会影响下面的子节点，只要考虑如何递归能够将一层的结点值倒过来。</p><p>运用到二叉树递归的一个技巧，【当递归函数参数只有一个结点难以实现递归时，可以考虑使用两个结点参数的递归函数】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">reverseOddLevels</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">reverseOddLevelsByDFS</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    dfs(root.left, root.right, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node1, TreeNode node2, <span class="type">int</span> level)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node1 == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果是奇数层，就交换对应结点的值</span></span><br><span class="line">    <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> node1.val;</span><br><span class="line">        node1.val = node2.val;</span><br><span class="line">        node2.val = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 通过两个结点一起递归，且该两个结点是处于对称位置</span></span><br><span class="line">    dfs(node1.left, node2.right, level+<span class="number">1</span>);</span><br><span class="line">    dfs(node1.right, node2.left, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bfs-迭代">BFS 迭代</h4><p>BFS迭代就是借助队列实现层次遍历，如果是奇数层做出对结点值的改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] values;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">reverseOddLevelsByBFS</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列中放的是奇数层，将这一层的值取出来放在values数组中</span></span><br><span class="line">        <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            values = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                values[i] = node.val;</span><br><span class="line">                queue.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 改造一下常规框架，如果是奇数层，再将结点poll出来之后，根据values数组改变其值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">1</span>)&#123; <span class="comment">// 如果是奇数层就改变值</span></span><br><span class="line">                node.val = values[size - i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串的前缀分数和">6183. 字符串的前缀分数和</h3><blockquote><p><ahref="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/">题目</a></p></blockquote><p>在前缀树的基础上，这道题就十分简单了，只需要稍微改造一下前缀树，在插入word的过程中每经过一个结点就+1，然后再提供一个计算word得分的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改造 Trie 树 在每一个结点里增加一个 cnt 统计在插入过程中 经过该结点的单词个数</span></span><br><span class="line"><span class="comment">也就是以 到这个结点为至形成的prefix 开始的单词数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sumPrefixScores(String[] words) &#123;</span><br><span class="line">    <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        root.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[words.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        answer[i] = root.getScores(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.children[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.children[idx] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur.children[idx].cnt ++; <span class="comment">// 经过这个结点的单词数++</span></span><br><span class="line">            cur = cur.children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得该word的得分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScores</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[idx] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不存在这个word, 对于已存在的word肯定不会出现这个情况</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                score += cur.children[idx].cnt;</span><br><span class="line">                cur = cur.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[idx] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.children[idx] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板-208.-实现-trie-前缀树">模板: 208. 实现 Trie (前缀树)</h4><blockquote><p><ahref="https://leetcode.cn/problems/implement-trie-prefix-tree/">题目</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Trie的原理: 每一个结点都包含一个指向 size = 26 的数组的引用</span></span><br><span class="line"><span class="comment">插入一个单词就是 从根节点依次向下新增结点 在数组对应位置(对应下标的字符 - &#x27;a&#x27;) 创建结点Trie</span></span><br><span class="line"><span class="comment">26cha&#x27;shu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.children[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.children[idx] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[idx] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.children[idx] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单周赛-1">327单周赛</h2><blockquote><p>时间：2023-01-08</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230108222540372.png" /></p><p>在第三道题浪费了太多时间，第四道题比较复杂，思路不清晰。</p></blockquote><h3 id="使字符串总不同字符的数目相等第三题"><ahref="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">6284.使字符串总不同字符的数目相等(第三题)</a></h3><blockquote><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230108222913402.png" /></p></blockquote><p>这道题在做题时把问题想简单了，导致没有考虑全面，通过判题罚时找到漏洞。</p><p>其实可以将两个字符串的字符出现情况用两个数组记录下来，然后双重循环即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isItPossible</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a1</span><span class="params">(<span class="number">26</span>)</span></span>; <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word1) a1[c-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word2) a2[c-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a1) s1 += i &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a2) s2 += i &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(s1 - s2) &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &gt; <span class="number">0</span> &amp;&amp; a2[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                a1[j]++; a1[i]--; a2[j]--; a2[i]++;</span><br><span class="line">                s1 = <span class="number">0</span>; s2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k : a1) s1 += k &gt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k : a2) s2 += k &gt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                a1[j]--; a1[i]++; a2[j]++; a2[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过桥的时间第四题"><ahref="https://leetcode.cn/problems/time-to-cross-a-bridge/">6306.过桥的时间(第四题)</a></h3><blockquote><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230108223927959.png" /></p></blockquote><p>看了题解，核心就是<strong>四个堆</strong>，因为上面的流程无非就是四个步骤：从桥的左边到右边、从旧仓库取箱子、从桥的右边到左边、从新仓库放箱子，就可以对应这四个步骤建立四个堆。整个过程还是比较复杂的，需要仔细理解。</p><ul><li>==wait_l==：在桥左边等待的工人</li><li>==wait_r==：在桥右边等待的工人</li><li>==box_l==：在新仓库放箱子的工人</li><li>==box_r==：在旧仓库取箱子的工人</li></ul><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230109143846728.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCrossingTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = time.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) time[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">// 按照效率从高到低排序 使得下标最大的工人效率最低</span></span><br><span class="line">    <span class="built_in">sort</span>(time.<span class="built_in">begin</span>(), time.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="type">int</span> prof_a = a[<span class="number">0</span>] + a[<span class="number">2</span>]; <span class="type">int</span> prof_b = b[<span class="number">0</span>] + b[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (prof_a != prof_b) <span class="keyword">return</span> prof_a &lt; prof_b;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">4</span>] &lt; b[<span class="number">4</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; wait_l, wait_r; <span class="comment">// 大顶堆 top()是效率最低的工人</span></span><br><span class="line">    priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt;&gt; box_l, box_r; <span class="comment">// 小顶堆 top()是最快完成box任务的工人</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">// 记录时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一开始全部在左边等待</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) wait_l.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> LtoR = n &gt; <span class="number">0</span> &amp;&amp; !wait_l.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="type">bool</span> RtoL = !wait_r.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!LtoR &amp;&amp; !RtoL) &#123; <span class="comment">// 左右两边都没有工人等待</span></span><br><span class="line">            <span class="comment">// 找到box_l和box_r中最快完成任务的工人 更新时间</span></span><br><span class="line">            <span class="type">int</span> x = INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(!box_l.<span class="built_in">empty</span>()) x = <span class="built_in">min</span>(x, box_l.<span class="built_in">top</span>().first);</span><br><span class="line">            <span class="keyword">if</span>(!box_r.<span class="built_in">empty</span>()) x = <span class="built_in">min</span>(x, box_r.<span class="built_in">top</span>().first);</span><br><span class="line">            cur = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RtoL)&#123; <span class="comment">// 右边到左边</span></span><br><span class="line">            <span class="type">int</span> x = wait_r.<span class="built_in">top</span>(); <span class="comment">// 取出右边效率最低的工人x</span></span><br><span class="line">            wait_r.<span class="built_in">pop</span>();</span><br><span class="line">            cur += time[x][<span class="number">2</span>]; <span class="comment">// 让x工人过桥</span></span><br><span class="line">            <span class="comment">// 检查是否是最后一个工人到达桥左岸</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; wait_r.<span class="built_in">empty</span>() &amp;&amp; box_r.<span class="built_in">empty</span>()) <span class="keyword">return</span> cur;</span><br><span class="line">            box_l.<span class="built_in">push</span>(<span class="built_in">p</span>(cur+time[x][<span class="number">3</span>], x)); <span class="comment">// 过桥后到新仓库放箱子 放入box_l堆中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LtoR) &#123; <span class="comment">// 左边到右边</span></span><br><span class="line">            <span class="type">int</span> x = wait_l.<span class="built_in">top</span>(); <span class="comment">// 取出左边效率最低的工人x</span></span><br><span class="line">            wait_l.<span class="built_in">pop</span>();</span><br><span class="line">            cur += time[x][<span class="number">0</span>]; <span class="comment">// 让x工人过桥</span></span><br><span class="line">            box_r.<span class="built_in">push</span>(<span class="built_in">p</span>(cur+time[x][<span class="number">1</span>], x)); <span class="comment">// 过桥后到旧仓库取箱子 放入box_r堆中</span></span><br><span class="line">            n--; <span class="comment">// 箱子数-1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!box_l.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p worker = box_l.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">// 如果在桥上的工人过桥的时间里，有工人能够完成box任务，就将他们放到对应的桥边等待队列中</span></span><br><span class="line">            <span class="keyword">if</span> (worker.first &gt; cur) <span class="keyword">break</span>;</span><br><span class="line">            box_l.<span class="built_in">pop</span>();</span><br><span class="line">            wait_l.<span class="built_in">push</span>(worker.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!box_r.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p worker = box_r.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">// 如果在桥上的工人过桥的时间里，有工人能够完成box任务，就将他们放到对应的桥边等待队列中</span></span><br><span class="line">            <span class="keyword">if</span> (worker.first &gt; cur) <span class="keyword">break</span>;</span><br><span class="line">            box_r.<span class="built_in">pop</span>();</span><br><span class="line">            wait_r.<span class="built_in">push</span>(worker.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似的题目：</p><p><a href="https://leetcode.cn/problems/single-threaded-cpu/">1834.单线程 CPU</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">leetcode刷题笔记</category>
      
      
      <category domain="http://example.com/tags/leetcode/">leetcode</category>
      
      
      <comments>http://example.com/2023/01/09/%E5%91%A8%E8%B5%9B%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>区间求和</title>
      <link>http://example.com/2023/01/05/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</link>
      <guid>http://example.com/2023/01/05/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</guid>
      <pubDate>Wed, 04 Jan 2023 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/range-sum-query-mutable/&quot;&gt;307.
区域和检索 - 数组可修改&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区间求和是算法中非常常见</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307.区域和检索 - 数组可修改</a></p></blockquote><p>区间求和是算法中非常常见的一个类型题目，一般有两个操作：</p><ol type="1"><li>单点更新</li><li>区间求和</li></ol><p>然后不同的题目会对上面两种操作的调用次数不同</p><h2 id="普通方法">1、普通方法</h2><h3 id="普通数组">1.1、普通数组</h3><ul><li>单点更新：<span class="math inline">\(O(1)\)</span></li><li>区间求和：<span class="math inline">\(O(N)\)</span></li></ul><h3 id="前缀和数组">1.2、前缀和数组</h3><ul><li>单点更新：<span class="math inline">\(O(N)\)</span></li><li>区间求和：<span class="math inline">\(O(1)\)</span></li></ul><blockquote><p>无论是哪一种方式，如果单点更新和区间求和的次数相当，并且都十分多时，效率是不高的。</p><p>但是如果某一种操作的调用次数非常高，可以使用对应的方式。</p><p>例如有些题目，数组初始化后就不再改变，只是不断地求区间和，就可以使用前缀和。</p></blockquote><h2 id="分块">2、分块</h2><blockquote><p>分块的思想是，由于单点更新和区间求和的调用次数相当，所以希望尽可能平摊在两个操作上的时间复杂度</p></blockquote><p>【操作】</p><ol type="1"><li>将数组分成 <span class="math inline">\(\sqrt{N}\)</span> 块，每块有<span class="math inline">\(\sqrt{N}\)</span> 个元素</li><li>单点更新：在某个块内遍历：<spanclass="math inline">\(O(\sqrt{N})\)</span></li><li>区间求和：最多将 <span class="math inline">\(\sqrt{N}\)</span>个块加在一起：<span class="math inline">\(O(\sqrt{N})\)</span></li></ol><h2 id="树形数组">3、树形数组</h2><figure><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029210540933.png"alt="image-20221029210540933" /><figcaption aria-hidden="true">image-20221029210540933</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Binary Index Tree</span></span><br><span class="line"><span class="comment"> * 树状数组</span></span><br><span class="line"><span class="comment"> * 思想是: 前缀区间的差集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BIT</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        len = n + <span class="number">1</span>;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做单点更新</span></span><br><span class="line"><span class="comment">     * 要把包含了nums[i]的元素全部更新</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 增加的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span>&#123;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">            tree[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 下标 i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 前 i 个元素之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= lowbit(i); <span class="comment">// 不断去掉(二进制表示下)最后一个1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树">4、线段树</h2><figure><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221029210553764.png"alt="image-20221029210553764" /><figcaption aria-hidden="true">image-20221029210553764</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线段树</span></span><br><span class="line"><span class="comment"> * 用二分的方式来对树进行划分</span></span><br><span class="line"><span class="comment"> * 思想是: 若干区间的并集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] st;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        buildTree(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    二叉树的性质:</span></span><br><span class="line"><span class="comment">            1、已知父节点下标 i，求出左右子节点的下标 i &gt;&gt; 1 和 (i &gt;&gt; 1) | 1</span></span><br><span class="line"><span class="comment">            2、已知左右子节点下标 i，求出父节点下标 i &lt;&lt; 1</span></span><br><span class="line"><span class="comment">            3、对于完美二叉树来说，整棵树的节点总数 = 2 * 叶子节点总数</span></span><br><span class="line"><span class="comment">    从最底层开始建树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * n];</span><br><span class="line">        <span class="comment">// 先构建叶子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; <span class="number">2</span> * n; i++)&#123;</span><br><span class="line">            st[i] = nums[i - n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建非叶子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">// st[i &lt;&lt; 1] 和 st[(i &lt;&lt; 1) | 1] 分别代表 左子节点 和 右子节点</span></span><br><span class="line">            st[i] = st[i &lt;&lt; <span class="number">1</span>] + st[(i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> delta)</span>&#123;</span><br><span class="line">        index += n;</span><br><span class="line">        <span class="keyword">while</span> ( index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            st[index] += delta;</span><br><span class="line">            index = index &gt;&gt; <span class="number">1</span>; <span class="comment">// 向上找到父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        l += n; r += n;</span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (l &amp; <span class="number">1</span>) == <span class="number">1</span> )&#123; <span class="comment">// l是右子节点</span></span><br><span class="line">                sum += st[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( (r &amp; <span class="number">1</span>) == <span class="number">0</span> )&#123; <span class="comment">// r是左子节点</span></span><br><span class="line">                sum += st[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">leetcode刷题笔记</category>
      
      
      <category domain="http://example.com/tags/leetcode/">leetcode</category>
      
      
      <comments>http://example.com/2023/01/05/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>编译原理Lab5</title>
      <link>http://example.com/2022/12/30/compilation-principle-lab5/</link>
      <guid>http://example.com/2022/12/30/compilation-principle-lab5/</guid>
      <pubDate>Thu, 29 Dec 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;实验过程&quot;&gt;实验过程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a
href=&quot;http://47.122.3.40:8081/#/lab5-function-and-var/lab5-function-and-var&quot;&gt;本次实验&lt;/a&gt;通过重新设计符号表</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="实验过程">实验过程</h2><blockquote><p><ahref="http://47.122.3.40:8081/#/lab5-function-and-var/lab5-function-and-var">本次实验</a>通过重新设计符号表，使用Visitor函数遍历语法树并在合适的函数内调用LLVM的API完成了对函数定义和函数调用，以及局部变量的声明、定义和使用的翻译。</p></blockquote><p>==重新设计符号表==：整体上符号表的结构没有改变，只是需要记录的信息变成了<code>LLVMValueRef</code>和<code>LLVMTypeRef</code>。<u>注意存在符号表里的<code>LLVMValueRef</code>是指针，而不是变量本身。</u></p><p>==翻译==：翻译过程并不复杂，但是需要注意很多细节！</p><h2 id="遇到的问题">遇到的问题</h2><p>==BUGs==：<strong>1</strong>、<code>void</code>函数可以没有返回语句，但是翻译时要将其加上；<strong>2</strong>、<code>(exp)</code>的<code>visitor</code>函数需要重写使其返回<code>exp</code>的<code>LLVMValueRef</code>；<strong>3</strong>、形如<code>x[x[0]]</code>的翻译中，当其作为左值时要注意，里面的<code>x[0]</code>返回的应是本身的值，而外面的<code>x[]</code>返回的应该是指针，由于两者都属于<code>LVal</code>，所以在遍历翻译是需要加以区分。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <category domain="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <comments>http://example.com/2022/12/30/compilation-principle-lab5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Lab3 Page Tables</title>
      <link>http://example.com/2022/12/27/6.S081-lab3-pgtbl/</link>
      <guid>http://example.com/2022/12/27/6.S081-lab3-pgtbl/</guid>
      <pubDate>Mon, 26 Dec 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;lecture-4-chapter-3&quot;&gt;0 lecture 4 &amp;amp; chapter 3&lt;/h2&gt;
&lt;h3 id=&quot;lecture-4&quot;&gt;Lecture 4&lt;/h3&gt;
&lt;h3 id=&quot;chapter-3-page-tables&quot;&gt;Chapter 3 P</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="lecture-4-chapter-3">0 lecture 4 &amp; chapter 3</h2><h3 id="lecture-4">Lecture 4</h3><h3 id="chapter-3-page-tables">Chapter 3 Page tables</h3><h4 id="xv6的页表映射机制">xv6的页表映射机制</h4><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221225144537100.png" /></p><h4 id="xv6-内核地址空间">xv6 内核地址空间</h4><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221225144757600.png" /></p><h4 id="xv6的页表代码">xv6的页表代码</h4><blockquote><p><code>vm.c</code></p></blockquote><p>核心数据结构：==pagetable_t==</p><p>核心函数：==walk== 和 ==mappages==</p><h4 id="物理地址分配代码">物理地址分配代码</h4><blockquote><p><code>kalloc.c</code></p></blockquote><p>核心数据结构：==kmem==</p><p>核心函数：==kfree== 和 ==kalloc==</p><h4 id="进程地址空间">进程地址空间</h4><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221225152730759.png" /></p><h4 id="系统调用sbrk-和-exec">系统调用：sbrk 和 exec</h4><p><strong>sbrk</strong>：为一个进程去减少或者增加它的内存（<code>kernel/sysproc.c</code>）</p><p><strong>exec</strong>：创建一个地址空间的用户部分</p><blockquote><p><font color='red'>what is trampoline?</font></p><p>trampolinepage存储了用户空间和内核空间相互切换的代码，无论是在内核空间还是在用户空间它都映射在相同的虚拟地址，这样在切换之后还可以继续工作。</p><p>相关文章：<ahref="https://xiayingp.gitbook.io/build_a_os/traps-and-interrupts/untitled-3">Whatis trampoline?</a></p><p><font color='red'>what is trapframe?</font></p><p><code>trapframe</code>是存在于用户地址空间，位于<code>trampoline</code>下面的大小为<code>PGSIZE</code>（4096字节）的一块内存，用于在用户地址空间向内核地址空间切换时保存用户空间的寄存器。</p></blockquote><h2 id="speed-up-system-calls">1 Speed up system calls</h2><p><u>任务描述</u>：加速<code>getpid()</code>系统调用。方法是在<code>trapframe</code>前面映射一个只读的页，在这个页的开始，存储一个结构体<code>syscall</code>，结构体里存储当前进程的<code>pid</code>，然后通过已经提供的<code>ugetpid()</code>函数获得<code>pid</code>。</p><p><u>思路</u>：可以参考<code>trapframe</code>的构造。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤</span></span><br><span class="line"><span class="comment">// 1. 在proc结构体中增加一个usyscall字段</span></span><br><span class="line"><span class="comment">// 2. 在allocproc()函数为usyscall分配空间，并且将pid存储在usyscall中</span></span><br><span class="line"><span class="comment">// 3. 在proc_pagetable()函数中将p-&gt;usyscall（物理地址）映射到USYSCALL（虚拟地址）</span></span><br><span class="line"><span class="comment">// 4. 在freeproc()函数中将usyscall的空间释放</span></span><br><span class="line"><span class="comment">// 5. 在proc_freepagetable()函数中取消之前建立的映射</span></span><br></pre></td></tr></table></figure><h2 id="print-a-page-table">2 Print a page table</h2><p><u>任务描述</u>：如题要求打印页表。</p><p><u>思路</u>：参考<code>freewalk</code>函数进行递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level &gt; <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(level == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; level; j++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(j != level - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">            level++;</span><br><span class="line">            vmprint((<span class="type">pagetable_t</span>)child);</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="detecting-which-pages-have-been-accessed">3 Detecting whichpages have been accessed</h2><p><u>任务描述</u>：检测页表是否被访问，实现<code>pgaccess</code>系统调用。</p><p><u>思路</u>：通过<code>walk</code>函数找到虚拟地址对应的<code>pte</code>，检查<code>PTE_A</code>位即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysproc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    uint64 base;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    uint64 mask;</span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;base) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    uint64 start = PGROUNDDOWN(base);</span><br><span class="line">    uint64 bitmask = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++, start += PGSIZE)&#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = walk(myproc()-&gt;pagetable, start, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// page not map</span></span><br><span class="line">        uint64 flag = (*pte &amp; PTE_A) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            *pte ^= PTE_A; <span class="comment">// clear the PTE_A</span></span><br><span class="line">        &#125;</span><br><span class="line">        bitmask |= (flag &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable, mask, (<span class="type">char</span> *)&amp;bitmask, <span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>:zap:访问页表时将<code>PTE_A</code>置1的工作由RISC-V硬件做了，在代码中不需要自己设置。</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/6-S081-OS-Labs/">6.S081 OS Labs</category>
      
      
      <category domain="http://example.com/tags/6-S081/">6.S081</category>
      
      
      <comments>http://example.com/2022/12/27/6.S081-lab3-pgtbl/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>编译原理-Lab4</title>
      <link>http://example.com/2022/12/22/compilation-principle-lab4/</link>
      <guid>http://example.com/2022/12/22/compilation-principle-lab4/</guid>
      <pubDate>Wed, 21 Dec 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;编译原理lab4&quot;&gt;编译原理Lab4&lt;/h1&gt;
&lt;h2 id=&quot;实验过程&quot;&gt;实验过程&lt;/h2&gt;
&lt;p&gt;总的来说，本次实验比较简单，只要弄清楚&lt;code&gt;LLVM&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;如何使用即可，核心在于编写&lt;code&gt;MyVisit</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="编译原理lab4">编译原理Lab4</h1><h2 id="实验过程">实验过程</h2><p>总的来说，本次实验比较简单，只要弄清楚<code>LLVM</code>的<code>API</code>如何使用即可，核心在于编写<code>MyVisitor</code>类。</p><p>由于本次实验只涉及<code>main</code>函数以及<code>return</code>语句，并且<code>return</code>语句中的表达式都是由<code>INTEGR_CONST</code>组成，所以只需要重写函数定义、返回语句、运算表达式以及数字这几个<code>visitor</code>函数即可。整体的逻辑比较简单，这里不做详细描述。</p><h2 id="遭遇的问题">遭遇的问题</h2><p>==关于如何找到正确API==：可以写一个包含想要寻找的操作的<code>.c</code>文件，用<code>clang</code>编译成<code>.ll</code>，从中找到<code>API</code>的大致名称。比如我在写<code>%</code>运算的时候，就是通过这种方法找到<code>srem</code>操作对应的<code>API</code>。</p><p>==关于导入依赖的报错==：导了一晚上的包，最后发现有关<code>linux</code>的包还是没有导入。经过搜索后，加入阿里云镜像，并且对<code>maven</code>的<code>import</code>进行配置，得以解决。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <category domain="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <comments>http://example.com/2022/12/22/compilation-principle-lab4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>操作系统-Lab4</title>
      <link>http://example.com/2022/12/15/OS-Lab4/</link>
      <guid>http://example.com/2022/12/15/OS-Lab4/</guid>
      <pubDate>Wed, 14 Dec 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;实验要求&quot;&gt;实验要求&lt;/h2&gt;
&lt;p&gt;&lt;img
src=&quot;https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201103215027.png&quot; /&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="实验要求">实验要求</h2><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201103215027.png" /></p><h2 id="源码理解">源码理解</h2><h3 id="运行源码">运行源码</h3><p><code>make run</code> 之后报错</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201105312262.png" /></p><p>和Lab3一样</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201105450390.png" /></p><h3 id="进程调度">进程调度</h3><p>在<code>kernel_main</code>函数中，为三个任务分配时间片和优先级如下</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206092451046.png" /></p><p>书中说是时钟中断每隔10ms发生一次，时钟中断处理程序如下</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206111157768.png" /></p><p>进程调度函数<code>schedule</code></p><p>调度的逻辑就是：<strong>找到剩余时间片最多（也就是优先级最高）的那个进程</strong></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206111347873.png" /></p><h2 id="实现过程">实现过程</h2><h3id="添加一个系统调用print_strchar-s">添加一个系统调用：print_str(char*s)</h3><p>实现完毕后出现bug：</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201155257376.png" /></p><p>原因是：该系统调用需要传递参数，但是由于源代码中的<code>sys_call</code>不支持传递参数，所以报错</p><p>解决方法：修改<code>sys_call</code>的汇编代码，将<code>ebx</code>中内容压入栈中，然后再进行系统调用，这样只要将参数存放在<code>ebx</code>中即可。（后续如果需要更多参数，就对应压入更多的寄存器中的值）</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221201181325369.png" /></p><h3id="添加一个系统调用sleepint-milli_seconds">添加一个系统调用：sleep(intmilli_seconds)</h3><p>该系统调用实现的是在指定的<code>milli_seconds</code>中不被分配时间片。</p><p>实现方式，手册中给了提示</p><p>1、修改<code>PROCESS</code>结构体，增加一个<code>wake_tick</code>字段，指示该进程醒来的时间片。</p><p>2、修改<code>schedule</code>函数，在进程调度时需要增加对<code>wake_tick</code>的判断，可以参与进程调度的应该是<code>wake_tick&lt;=current_tick</code>的进程。</p><h3 id="模拟读者写者">模拟读者写者</h3><blockquote><p><strong>注意点</strong></p><p>一个读进程被选中开始读一个时间片之后，另一个读进程被调入开始读的这一个时间中，前一个读进程应该仍然保持读状态，直至读结束。</p></blockquote><blockquote><p>需要实现三种策略：读者优先、写者优先、读写公平（防止饿死）</p><p>允许同时读的进程数需要能够改变（<code>n=1,2,3</code>）</p><p>每个进程读写结束之后休息的时间片可以随意修改(<spanclass="math inline">\(t \ge 0\)</span>)</p><p>（具体的PV操作以及三种策略对应的读写函数见代码）</p></blockquote><p>1、<strong>三种策略</strong></p><p>使用表驱动的实现方式，建立函数数组，依据不同的策略去调用数组中对应的读写函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* reader_func)</span><span class="params">()</span>; <span class="comment">// 读者函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* writer_func)</span><span class="params">()</span>; <span class="comment">// 写者函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRATEGY    3</span></span><br><span class="line"><span class="comment">// 读写策略</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READER_FIRST 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITER_FIRST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_EQUALITY  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// global.c</span></span><br><span class="line">PUBLIC reader_func readers[STRATEGY] = &#123;</span><br><span class="line">    reader_first_r,</span><br><span class="line">    writer_first_r,</span><br><span class="line">    rw_equality_r</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PUBLIC writer_func writers[STRATEGY] = &#123;</span><br><span class="line">    reader_first_w,</span><br><span class="line">    writer_first_w,</span><br><span class="line">    rw_equality_w</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line">strategy = READER_FIRST;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadB</span><span class="params">()</span>&#123;</span><br><span class="line">readers[strategy]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteE</span><span class="params">()</span>&#123;</span><br><span class="line">writers[strategy]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、同时读的进程数</p><p>使用一个信号量控制读者进程数量<code>r_mutex</code>，其<code>value</code>初值为<code>READER_MAX</code></p><p>3、读写之后的休息时间</p><p>在<code>PROCESS</code>结构体中增加一个<code>sleep_time</code>字段，在完成读写后调用<code>sleep</code>函数即可</p><p>4、<code>PROCESS</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_proc</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> wake_tick;  <span class="comment">// 进程醒来的时间片</span></span><br><span class="line"><span class="type">int</span> state;<span class="comment">// 进程的状态</span></span><br><span class="line"><span class="type">int</span> type; <span class="comment">// 进程的类型</span></span><br><span class="line"><span class="type">int</span> run_after_sleep; <span class="comment">// 判断进程此时是否是醒来立刻运行的</span></span><br><span class="line"><span class="type">int</span> sleep_time; <span class="comment">// 进程休息的时间片数量</span></span><br><span class="line">&#125;PROCESS;</span><br></pre></td></tr></table></figure><p>5、<strong><code>schedule</code>函数</strong></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221217144338875.png" /></p><blockquote><p>注意：要调度<strong>所有的</strong>睡醒的进程、调度<strong>所有的</strong>结束进程释放资源、调度<strong>所有的</strong>waiting进程。因为逻辑上他们就是要同步进行的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC <span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PROCESS* p = proc_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isRunnable(p))&#123; <span class="comment">// 优先选择A</span></span><br><span class="line">p_proc_ready = p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 先去找刚睡醒的进程，尝试调度他们</span></span><br><span class="line"><span class="keyword">for</span> (PROCESS* i = proc_table + <span class="number">1</span>; i &lt; proc_table + NR_TASKS; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;state == SLEEPING &amp;&amp; i-&gt;wake_tick &lt;= get_ticks())&#123;</span><br><span class="line">i-&gt;state = RUNNING;</span><br><span class="line">i-&gt;run_after_sleep = <span class="number">1</span>;</span><br><span class="line">p_proc_ready = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再找到tick=0的进程 去释放资源</span></span><br><span class="line"><span class="keyword">for</span> (PROCESS* i = proc_table + <span class="number">1</span>; i &lt; proc_table + NR_TASKS; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;ticks == <span class="number">0</span>)&#123;</span><br><span class="line">p_proc_ready = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调度waiting的进程 不用等信号量的进程</span></span><br><span class="line"><span class="keyword">for</span> (PROCESS* i = proc_table + <span class="number">1</span>; i &lt; proc_table + NR_TASKS; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i-&gt;state == WAITING)&#123;</span><br><span class="line">i-&gt;state = RUNNING;</span><br><span class="line">p_proc_ready = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 都不存在按之前的顺序继续调度</span></span><br><span class="line">p = prev_proc + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!isRunnable(p))&#123;</span><br><span class="line">p++;</span><br><span class="line"><span class="keyword">if</span>(p &gt;= proc_table + NR_TASKS)&#123;</span><br><span class="line">p = proc_table;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p_proc_ready = p;</span><br><span class="line">prev_proc = p;</span><br><span class="line">&#125;</span><br><span class="line">p_proc_ready-&gt;state = RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：调度了刚睡醒的进程后，如果其可以成功执行，要在开始执行后停止再次执行调度函数，因为需要将结束的进程的资源返回，同时尝试开启其他进程。（<code>run_after_sleep</code>字段就是为了执行这个功能）</p></blockquote><p>6、一个问题<code>reader_max=2 &amp;&amp; sleep_time=2</code>会有一个问题：B进程结束开始睡觉，C进程睡醒，D进程在睡觉，此时<code>rw_mutex</code>被写者进程抢走。</p><p>解决：<u>先调度刚睡醒的进程，然后调度要结束的进程</u>，保证刚睡醒的进程可以和其他进程一样在结束的进程返回资源之后一起竞争。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221215210022614.png" /></p><h2 id="实验">实验</h2><h3 id="中断返回">中断返回</h3><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221208101839093.png" /></p><p>schedule调度策略采用顺序调度，如下结果可以发现，当再次调度到A的时候是先打印的是<code>a.</code>，可见再次调度之后确实是从中断处继续执行的。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221208101741056.png" /></p><h3 id="进程调度-1">进程调度</h3><p>同样的sleep函数，一个是普通函数实现，一个是系统调用实现，结果是只有系统调用才能正确实现进程调度。</p><p>因为系统调用返回后回到<code>p_proc_ready</code>所指的进程中执行，而普通函数返回后仍然在原来函数中执行，即使<code>p_proc_ready</code>已经改变。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221208113136173.png" /></p><p><strong>奇怪的问题：</strong></p><p>右侧只是做了一些输出，结果就和左边不一样！</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221216001730954.png" /></p><p><strong>原因：</strong>在进程中直接调用了<code>schedule</code>函数改变了<code>p_proc_ready</code>，但是由于<code>schedule</code>函数在用户态执行完毕后返回原进程，就没有起到预想中的调度的作用。但是增加了一些输出就做到了，是因为输出方法是系统调用，会进入内核态，然后从内核态返回之后，就进入了<code>p_proc_ready</code>所指定的进程中执行，起到了调度的作用！</p><p>在图中红框部分，<code>0</code>和<code>t</code>本应该是<code>schedule</code>函数中相邻的两次输出，但是中间却夹着一部分字符，这一部分字符就是从第一个打印系统调用中返回后进入新的<code>p_proc_ready</code>指定的进程中执行的输出，出现乱码也应该是因为之前不正当使用<code>schedule</code>函数引起的。</p><p><strong>解决：</strong>用一个系统调用封装<code>schedule</code>函数供进程调用，修改后发现程序行为正常且一致。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221216002321372.png" /></p><h3 id="sleep和milli_delay的对比">sleep和milli_delay的对比</h3><p>对A任务进程执行 <code>milli_delay(100)</code></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206112309949.png" /></p><p>对A任务进程执行<code>sleep(100)</code></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221206112729973.png" /></p><p>两者的区别就在于：对A执行<code>sleep(100)</code>后就不参与进程调度了，所以只有B和C进程参与调度；但是对A执行<code>miili_delay(100)</code>，A只是在这<code>100ms</code>中不执行任何操作而已，仍然参与进程的调度。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <category domain="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <comments>http://example.com/2022/12/15/OS-Lab4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>编译原理-Lab3</title>
      <link>http://example.com/2022/12/13/compilation-principle-lab3/</link>
      <guid>http://example.com/2022/12/13/compilation-principle-lab3/</guid>
      <pubDate>Mon, 12 Dec 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a
href=&quot;http://47.122.3.40:8081/#/lab3-type-and-rename/lab3-type-and-rename&quot;&gt;本次实验&lt;/a&gt;主要分为两个部分：&lt;/p&gt;
&lt;p&gt;1、对程序进行类型检查，找到所有的语</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><ahref="http://47.122.3.40:8081/#/lab3-type-and-rename/lab3-type-and-rename">本次实验</a>主要分为两个部分：</p><p>1、对程序进行类型检查，找到所有的语义错误（11种）</p><p>2、若程序没有语义错误，则完成变量重命名后打印语法树</p></blockquote><h2 id="类型检查">类型检查</h2><h3 id="设计类型">设计类型</h3><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221217001208028.png" /></p><h3 id="设计符号表">设计符号表</h3><p>==Symbol类==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Symbol</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Type type;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Scope scope;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="type">int</span>[]&gt; usePos;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isNeedReplace;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> row;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> col;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Symbol</span><span class="params">(...)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加一个该符号被使用的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUsePos</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试使用</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==Scope类==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scope</span>&#123;</span><br><span class="line">    Scope enclosingScope;</span><br><span class="line">    Map&lt;String, Symbol&gt; symbols;</span><br><span class="line">    List&lt;Scope&gt; childScope;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Scope</span><span class="params">(...)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个符号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">define</span><span class="params">(Symbol symbol)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (全局)解析一个符号</span></span><br><span class="line">    <span class="keyword">public</span> Symbol <span class="title function_">resolve</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (在当前作用域下)解析一个符号</span></span><br><span class="line">    <span class="keyword">public</span> Symbol <span class="title function_">resolveCurrentScope</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加一个该作用域的子作用域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChildScope</span><span class="params">(Scope s)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后只需要在遍历语法树的过程中，在合适的位置创建作用域，并在合适的位置退出作用域，以及在函数定义、变量声明的对应处理函数中将变量包装成符号加入到作用域的符号列表中。</p><h3 id="处理语义错误">处理语义错误</h3><p>需要针对11种错误依次进行分析处理</p><table><colgroup><col style="width: 8%" /><col style="width: 30%" /><col style="width: 61%" /></colgroup><thead><tr class="header"><th>错误编号</th><th>错误说明</th><th>分析</th></tr></thead><tbody><tr class="odd"><td>1</td><td>变量未声明</td><td>在使用变量的位置，全局解析该符号，看是否定义该变量，可在<code>visitTerminal</code>函数中处理</td></tr><tr class="even"><td>2</td><td>函数未定义</td><td>在函数调用中处理，解析被调用的函数名，查看是否被定义</td></tr><tr class="odd"><td>3</td><td>变量重复声明</td><td>在声明变量的位置：函数形参，常量声明、变量声明三个地方，<u>注意解析时只要在当前作用域下解析</u>（和全局同名变量不冲突）</td></tr><tr class="even"><td>4</td><td>函数重复定义</td><td>在函数定义的位置，解析要定义的函数名，是否已经定义过</td></tr><tr class="odd"><td>5</td><td>赋值号两侧类型不匹配</td><td>出现在有赋值符号的位置：常量声明、变量声明并初始化、赋值语句，处理方式就是取得两边的类型，进行比较判断</td></tr><tr class="even"><td>6</td><td>运算符需求类型与提供类型不匹配</td><td>出现在有运算符的地方，<u>注意下标运算符<code>[]</code></u>，处理方式也是获取操作数的类型，检查是否匹配</td></tr><tr class="odd"><td>7</td><td>返回值类型不匹配</td><td>出现在返回语句中，由于函数类型只有<code>int</code>和<code>void</code>，如果没有返回值判断是否是<code>void</code>，如果有返回值就需要判断<code>return</code>后面的表达式返回的类型是否为<code>int</code></td></tr><tr class="even"><td>8</td><td>函数参数不适用</td><td>出现在函数调用中，可以先判断形参数量和实参数量，如果相同再进行一个一个的检查判断</td></tr><tr class="odd"><td>9</td><td>对非数组使用下标运算符</td><td>在出现下标运算符时检查变量是否是数组类型，<u>注意对数组类型变量使用超过其维数的下标运算符个数</u>（例如对一维数组使用两个下标运算符）</td></tr><tr class="even"><td>10</td><td>对变量使用函数调用</td><td>出现在函数调用中，判断变量类型是否是函数类型</td></tr><tr class="odd"><td>11</td><td>赋值号左侧非变量或数组元素</td><td>出现在左值表达式中，如果是赋值语句，判断左侧的符号类型是否为函数类型</td></tr></tbody></table><blockquote><p>这一部分最麻烦的是，一个错误会引起连锁错误，但是要求只打印"最本质错误"。</p><p>我在处理的过程中采用：一旦出现错误之后，返回的类型都是<code>null</code>，而上层的函数只有在下层函数不返回<code>null</code>是才会在这一层进行错误检查，否则直接返回。但是需要注意的是，不是每一个函数返回null都代表出现错误，还需要结合具体情况分析，不过大部分都适用。</p></blockquote><h2 id="重命名">重命名</h2><blockquote><p>为所有与选中变量<strong>生命周期一致</strong>的<strong>同名变量</strong>重命名</p></blockquote><p>思路：</p><p>在第一次遍历语法树的过程中，解析变量之后将该变量的位置加入到符号的<code>usePos</code>列表中，并且找到需要重命名的那个变量(<code>isNeedReplace</code>)。在第二次遍历过程中，将需要重命名的那个符号的<code>usePos</code>取出，遍历到对应位置后进行重命名即可。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221217105317387.png" /></p><h2 id="碰到的问题">碰到的问题</h2><p>感觉比较困难的地方主要还是在第一部分语义错误检查，因为出错了之后需要自己想用例去排查，而且“最本质错误”的要求导致bug比较难以找到。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <category domain="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <comments>http://example.com/2022/12/13/compilation-principle-lab3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>编译原理-Lab2</title>
      <link>http://example.com/2022/11/24/compilation-principle-lab2/</link>
      <guid>http://example.com/2022/11/24/compilation-principle-lab2/</guid>
      <pubDate>Wed, 23 Nov 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a
href=&quot;http://47.122.3.40:8081/#/lab2-parser/lab2-parser&quot;&gt;实验内容&lt;/a&gt;：编写SysY语言的语法分析器，并实现高亮。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实验思</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p><ahref="http://47.122.3.40:8081/#/lab2-parser/lab2-parser">实验内容</a>：编写SysY语言的语法分析器，并实现高亮。</p></blockquote><h2 id="实验思路">实验思路</h2><p>首先需要根据<ahref="https://github.com/courses-at-nju-by-hfwei/compilers-lab-docs/raw/main/docs/docs/SysY%E8%AF%AD%E8%A8%80%E5%AE%9A%E4%B9%89.pdf">SysY语言定义</a>编写Parser，这部分基本上就是将手册上的语法规则改写成<code>Antrl</code>语句即可。</p><p>然后就可以到<code>Main</code>类中编写相应的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;input path is required&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get input file and generate the Lexer</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">CharStream</span> <span class="variable">input</span> <span class="operator">=</span> CharStreams.fromFileName(source);</span><br><span class="line">        <span class="type">SysYLexer</span> <span class="variable">sysYLexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysYLexer</span>(input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// generate the Parser</span></span><br><span class="line">        <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(sysYLexer);</span><br><span class="line">        <span class="type">SysYParser</span> <span class="variable">sysYParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysYParser</span>(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Visitor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add error listener</span></span><br><span class="line">        sysYParser.removeErrorListeners();</span><br><span class="line">        <span class="type">MyParserErrorListener</span> <span class="variable">myParserErrorListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyParserErrorListener</span>(visitor);</span><br><span class="line">        sysYParser.addErrorListener(myParserErrorListener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DFS the tree</span></span><br><span class="line">        <span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> sysYParser.program();</span><br><span class="line">        visitor.visit(tree);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>类似于Lab1，需要实现一个自定义的<code>ErrorListener</code>，传递给<code>Parser</code>，使得在发现语法错误时执行报错输出。</p><blockquote><p>为什么要传递<code>Visitor</code>?</p><p>由于一旦出现语法错误，就不需要打印语法树了，所以需要在<code>ErrorListener</code>监听到语法错误时让<code>Visitor</code>不要做输出。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyParserErrorListener</span> <span class="keyword">extends</span> <span class="title class_">BaseErrorListener</span>&#123;</span><br><span class="line">    Visitor visitor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyParserErrorListener</span><span class="params">(Visitor v)</span>&#123; <span class="built_in">this</span>.visitor = v; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntaxError</span><span class="params">(Recognizer&lt;?, ?&gt; recognizer,</span></span><br><span class="line"><span class="params">                            Object offendingSymbol,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> line,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> charPositionInLine,</span></span><br><span class="line"><span class="params">                            String msg,</span></span><br><span class="line"><span class="params">                            RecognitionException e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.visitor.hasError = <span class="literal">true</span>;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error type B at Line &quot;</span> + line + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后也是最关键的，编写继承自<code>SysYParserBaseVisitor&lt;Void&gt;</code>的<code>Visitor</code>，实现打印语法树以及高亮的功能。</p><ol type="1"><li>如何打印节点信息：在<code>visitChildren</code>和<code>visitTerminal</code>两个函数中，调用参数<code>node</code>的相关方法就可以获得<code>type</code>、<code>text</code>等信息。</li><li>如何实现缩进：存在<code>depth</code>字段，调用<code>node.getRuleContext().depth()</code>获得；注意在<code>visitTerminal</code>函数中需要强转一下类型。</li><li>如何实现高亮：在<code>SysYParser</code>中找到对应的存放节点类型的数组，将数组中的值修改为对应的颜色值，每次根据<code>type</code>获取对应颜色。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Visitor</span> <span class="keyword">extends</span> <span class="title class_">SysYParserBaseVisitor</span>&lt;Void&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">hasError</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getColor</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt;= _COLOR_NAMES.length) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> _COLOR_NAMES[type];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] _COLOR_NAMES = &#123;</span><br><span class="line">            <span class="literal">null</span>, <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[orange]&quot;</span>,</span><br><span class="line">            <span class="string">&quot;[orange]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>,</span><br><span class="line">            <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;[blue]&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;[green]&quot;</span>,</span><br><span class="line">            <span class="string">&quot;[red]&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printIndents</span><span class="params">(<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; depth * <span class="number">2</span>; i++)&#123;</span><br><span class="line">            System.err.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">visitChildren</span><span class="params">(RuleNode node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ruleIdx</span> <span class="operator">=</span> node.getRuleContext().getRuleIndex();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rule</span> <span class="operator">=</span> SysYParser.ruleNames[ruleIdx];</span><br><span class="line">        <span class="keyword">if</span> (!hasError)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> node.getRuleContext().depth();</span><br><span class="line">            printIndents(depth-<span class="number">1</span>); <span class="comment">// need -1: depth begin from 1</span></span><br><span class="line">            System.err.println(rule.toUpperCase().charAt(<span class="number">0</span>) + rule.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitChildren(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">visitTerminal</span><span class="params">(TerminalNode node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> node.getSymbol().getType(); <span class="comment">// node type</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> getColor(type);</span><br><span class="line">        <span class="keyword">if</span> (!hasError &amp;&amp; !color.equals(<span class="string">&quot;&quot;</span>))&#123; <span class="comment">// &quot;&quot; means the terminal node we need, such as &#x27;&#123;&#x27; &#x27;&#125;&#x27;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">literal_name</span> <span class="operator">=</span> node.toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">symbol_name</span> <span class="operator">=</span> SysYParser.VOCABULARY.getSymbolicName(type);</span><br><span class="line">            <span class="comment">// deal with numbers</span></span><br><span class="line">            <span class="keyword">if</span> (type == SysYParser.INTEGR_CONST)&#123;</span><br><span class="line">                literal_name = convert_to_dec(literal_name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> ((RuleNode)node.getParent()).getRuleContext().depth(); <span class="comment">// the depth in parser tree</span></span><br><span class="line">            printIndents(depth);</span><br><span class="line">            System.err.println(literal_name + <span class="string">&quot; &quot;</span> + symbol_name + color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">convert_to_dec</span><span class="params">(String number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number.equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            number = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number.startsWith(<span class="string">&quot;0x&quot;</span>) || number.startsWith(<span class="string">&quot;0X&quot;</span>))&#123;</span><br><span class="line">            number = Integer.parseInt(number.substring(<span class="number">2</span>), <span class="number">16</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            number = Integer.parseInt(number.substring(<span class="number">1</span>), <span class="number">8</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="碰到的问题">碰到的问题</h2><h3 id="缩进">缩进</h3><p>如何按层次缩进是做实验的时候碰到的最大的一个问题。一开始没想到会有<code>depth</code>字段，一直在想如何通过一个变量来标记层次，结果一直没有成功，因为两个<code>visit</code>函数都是进入节点之前调用，而没有对应的离开后调用的函数，所以不能通过在两个函数内的增减变化实现层次的变化（也许<code>Listener</code>应该是可以的）</p><h3 id="拼写">拼写</h3><p><code>INTEGR_CONST</code>。测试的时候看它输出在文件里报拼写错误，还以为是自己写错了，全部改成<code>INTEGER_CONST</code>，结果<code>OJ</code>过不了，后来发现在<code>Lab1</code>的<code>Lexer</code>中写的就是<code>INTEGR_CONST</code>。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <category domain="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
      
      
      <comments>http://example.com/2022/11/24/compilation-principle-lab2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>操作系统-Lab3</title>
      <link>http://example.com/2022/11/21/OS-Lab3/</link>
      <guid>http://example.com/2022/11/21/OS-Lab3/</guid>
      <pubDate>Sun, 20 Nov 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;实验以《orange&#39;s：一个操作系统的实现》的&lt;a
href=&quot;https://github.com/wlmnzf/oranges/tree/master/chapter7/o&quot;&gt;代码&lt;/a&gt;为基础&lt;/p&gt;
&lt;h3 id=&quot;运</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="准备">准备</h2><p>实验以《orange's：一个操作系统的实现》的<ahref="https://github.com/wlmnzf/oranges/tree/master/chapter7/o">代码</a>为基础</p><h3 id="运行">运行</h3><h4 id="问题1">问题1</h4><p>make image失败</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108200704537.png" /></p><p>解决方法</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108200905099.png" /></p><p>结果</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108201025947.png" /></p><h4 id="问题2">问题2</h4><p><code>make image</code>结束之后，执行下面的命令失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc</span><br></pre></td></tr></table></figure><p>报错信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlopen failed for module &#x27;x&#x27;: file not found</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bochs-x</span><br></pre></td></tr></table></figure><p>结果显示</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221108201337846.png" /></p><h3 id="已实现和待实现">已实现和待实现</h3><h4 id="已实现">已实现</h4><ol type="1"><li>从屏幕左上角开始，以白色显示键盘输入的字符，可以输入并显示a-z,A-Z和0-9字符。</li><li>支持大小写切换包括 Shift 组合键以及大写锁定两种方式，大写锁定后再用Shift 组合键将会输入小写字母</li><li>支持回车键换行</li><li>支持用退格键删除输入内容</li><li>支持空格键</li><li>有光标显示</li><li>输入字符无上限</li></ol><h4 id="待实现">待实现</h4><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />make run直接运行</li><li><input type="checkbox" disabled="" checked="" />支持Tab键</li><li><input type="checkbox" disabled=""checked="" />清空屏幕以及每隔20秒清空屏幕</li><li><input type="checkbox" disabled=""checked="" />退格换行和TAB需要一次完成</li><li><input type="checkbox" disabled="" checked="" />查找功能</li><li><input type="checkbox" disabled="" checked="" />control + z组合键撤回</li></ul><h2 id="理解代码">理解代码</h2><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112082935878.png" /></p><p>首先，需要理解代码，可以照着《orange's：一个操作系统的实现》第七章的讲解一起看。</p><p>输出一个字符的函数调用逻辑</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221110203047699.png" /></p><p>当初始化结束后，就会进入到<code>task_tty()</code>函数中，进行不断的循环。</p><h3id="探究console结构体中四个变量的含义">探究CONSOLE结构体中四个变量的含义</h3><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111162034665.png" /></p><p><strong>分析过程</strong></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111090406115.png" /></p><p><u>屏幕一行80个字符，屏幕总共25行。</u></p><p>在敲字符过程中，<u><code>cursor</code>在不断加1</u>，<u><code>original_addr</code>始终为<code>0x0</code></u>，<code>current_start_addr</code>是<u>当前屏幕可见范围的开始位置</u>距离<u>最开始显示位置</u>的偏移。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111091301955.png" /></p><p>按到最后</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111162617930.png" /></p><p>可以发现<code>cursor</code>的值最大只能到<code>0x1554</code>，因为被<code>v_mem_limit</code>所限制。</p><p>经过分析就可以基本确定CONSOLE结构体四个变量的含义，用一张图来表示一下</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111164821213.png" /></p><h2 id="实现功能">实现功能</h2><h3 id="tab">TAB</h3><p>在<code>keyboard.h</code>中可以发现TAB是一个不可显示的字符，所以在<code>tty.c</code>的<code>in_process</code>中要增加对于<code>TAB</code>的识别，将其放进缓冲区内。然后在<code>console.c</code>的<code>out_char</code>函数中增加对<code>\t</code>的输出处理。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160733005.png" /></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160949600.png" /></p><h3 id="清屏">清屏</h3><p>清屏的功能实现在逻辑上比较简单，只要不断地调用<code>out_char()</code>函数，传入<code>\b</code>，直到<code>cursor</code>回到<code>original_addr</code>位置。</p><p>但是如何在实现每20秒清屏一次呢？要理解<code>kernel_main()</code>函数中的任务，可以新增一个任务，<code>task_clear_screen</code>，然后在其中执行清屏任务，并且每次执行完毕后延迟20s。</p><p>1、将<code>task_clear_screen</code>声明成一个任务，不断执行</p><p>在<code>global.c</code>中做相应修改，并修改对应的宏</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112161118740.png" /></p><p>2、在<code>task_clear_screen</code>任务中完成清屏逻辑，并且延迟20s</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111215247007.png" /></p><blockquote><p>每个任务中while循环不能break，否则执行会报错。</p></blockquote><h3 id="退格一次完成">退格一次完成</h3><p>源代码的删除功能只实现了一个一个删除，即使是对于<code>\n</code>和<code>\t</code>也是如此，不符合实际情况，需要做修改，实现一次删除<code>\t</code>和<code>\n</code>。</p><p><strong>思路</strong></p><p>要想实现一次退格，就需要知道前一个字符是什么，如果是普通字符那么让光标位置减一即可，如果是特殊的<code>\n</code>和<code>\t</code>就需要特殊处理，使光标回到按下<code>\n</code>和<code>\t</code>前的位置。</p><p>对于<code>\t</code>还好说，只要把光标减4即可；但是对于<code>\n</code>来说，就有点麻烦了。</p><p>一开始，想让光标一直往回移动直到遇到不是空格的字符。但是如果在输入<code>\n</code>之前刚输入了空格呢？这样显然就不对，而且实现起来还很复杂。</p><p>所以需要借助新的数据结构来存储已经显示的字符，并且对显示的字符做一个包装，做成一个结构体。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111192544494.png" /></p><p>再构建一个存储当前屏幕中所有显示的字符的结构体</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111192521635.png" /></p><p>然后需要在适当的地方将这个数据结构插入</p><p><strong>过程</strong></p><p>1、初始化C_BUF结构体</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193022381.png" /></p><p>2、在将字符放入TTY中的同时，也将封装起来的字符放进C_BUF中</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193053341.png" /></p><p>3、<strong>在<code>out_char</code>函数中实现对应逻辑</strong></p><p>在其他输出字符的位置需要加上对CHAR结构体中before_cursor和after_cursor的赋值，例如：</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193614434.png" /></p><p>然后在处理退格键时就可以用如下一段代码解决</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193431518.png" /></p><p>4、显示字符结束后，需要修改C_BUF中的<code>buf_cur_idx</code></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221111193124708.png" /></p><p><strong>这么设计就可以把所有的字符统一起来处理，在退格时只要回到按下该键前的光标位置即可。</strong></p><blockquote><p>注意需要把p_cbuf作为全局变量声明，这样可以在所有文件中使用，而不用作为函数参数传来传去。</p><p><u>在global.c和global.h中做声明即可</u></p></blockquote><h3 id="查找功能">查找功能</h3><p><strong>思路</strong></p><p>明确几个状态(代码也是依据状态编写的)</p><p>1、正常状态。以黑底白字显示字符，一切正常</p><p>2、搜索状态。在正常状态按下esc后，<u>以黑底红字显示字符</u>，并<u>记录这段时间敲下的字符</u>。</p><p>3、匹配状态。搜索状态按下enter后，进行match，思路是<u>从头遍历C_BUF结构体数组，找到匹配的字符串后把相应的字符颜色改成黑底红字，再从头显示</u>。</p><p>4、从匹配态退出。<u>删去搜索字符串</u>，<u>把黑底红字的改成黑底白字</u>，<u>重新显示</u>。</p><p><strong>过程</strong></p><p>1、定义一些全局变量和常量，对CHAR结构体进行调整(增加color字段)</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145803256.png" /></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112144313280.png" /></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112144339441.png" /></p><p>状态的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT(按ESC) -&gt; SEARCH(按Enter) -&gt; MATCH(按ESC) -&gt; INIT</span><br></pre></td></tr></table></figure><p>2、在每个状态编写相应逻辑</p><p><strong>INIT</strong></p><p>在<code>in_process</code>函数中增加对ESC的识别</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112144935869.png" /></p><p>这个初始化要小心，每次进入搜索状态都要进行初始化</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145609113.png" /></p><p><strong>SEARCH</strong></p><p>改变in_process中对Enter键的处理</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145035952.png" /></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145542894.png" /></p><p><strong>MATCH</strong></p><p>在in_process函数开头加上判断，只接收ESC</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145201780.png" /></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145515851.png" /></p><p>在out_char函数中也要做相应处理</p><p>1、MATCH状态下是不需要向C_BUF数组中增添CHAR的，只做输出。</p><p>2、SEARCH状态下要记录搜索字符串，并且注意SEARCH状态下是黑底红色。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112145247460.png" /></p><blockquote><p>注意：在退格搜索字符串时(<code>SEARCH</code>状态)，不能将原来的字符串删除。</p></blockquote><h3 id="controlz撤销">control+z撤销</h3><p>这个也很简单，首先要判断出是否是按下<code>ctrl+z</code>组合键，然后执行退格操作即可。</p><p>似乎没有那么简单，因为既要撤销显示出来的字符，还要撤销删除，以及需要能够一直撤销直到初始状态。</p><p>想法1：再建立一个ACTION的列表，记录所有的操作。但是实现起来可能比较复杂，因为需要同步好几个数据结构数组之间的关系。</p><p>想法2：改造C_BUF数据结构。其实撤销的主要难点在于撤销退格，所以在C_BUF中使用两个指针。也不行，可操作性不高，指针移动比较复杂。</p><p>最终采用想法1，需要理清ACTION数组在什么位置更新！</p><p>1、创建数据结构</p><p>其中<code>MAX_ACTION</code>为1000，即支持大约1000次撤销。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112155756326.png" /></p><p>2、初始化ACTION列表</p><p>在task_tty函数中调用初始化函数即可</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112155904351.png" /></p><p>3、向列表中增加ACTION</p><p>经过思考，选在tty_do_write函数的out_char后面</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160009078.png" /></p><p>4、撤销操作</p><p>在in_process函数中增加以下逻辑，就是在判断出是<code>Ctrl+z</code>组合键后，回退ACTION数组，做逆操作。</p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-note-imgs/image-20221112160101647.png" /></p><blockquote><p>注意虚拟机中的热键 VirtualBox默认是 Right Ctrl</p><p>导致Right Ctrl按不出来</p></blockquote><h3 id="总结">总结</h3><p>由于上面的描述是写完一个功能后立刻写下的，所以导致代码前后会出现不一致。</p><p>感觉十分重要的调整是 【将字符加进C_BUF结构体中buf 】的位置 和 【更新C_BUF结构体中 buf_cur_idx】 的位置，最后是都放在了out_char函数中。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <category domain="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <comments>http://example.com/2022/11/21/OS-Lab3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>刷题笔记11--面试必知必会</title>
      <link>http://example.com/2022/11/19/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B011%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89/</link>
      <guid>http://example.com/2022/11/19/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B011%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89/</guid>
      <pubDate>Fri, 18 Nov 2022 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;nsum问题&quot;&gt;1 nSum问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;nSum问题就是给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个
&lt;code&gt;target&lt;/code&gt;，要求找到 &lt;code&gt;n&lt;/code&gt;
个&lt;code&gt;nums</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="nsum问题">1 nSum问题</h2><blockquote><p>nSum问题就是给定一个整数数组 <code>nums</code> 和一个<code>target</code>，要求找到 <code>n</code>个<code>nums</code>中的元素，使得这<code>n</code>个元素的和等于<code>target</code>，要求返回所有可能的不重复的情况。</p></blockquote><p>【2Sum】问题是这类的基本情况，将数组排序后使用双指针即可解决问题。对于<spanclass="math inline">\(n &gt;2\)</span>的情况，尤其是<code>n</code>比较大时，直接解决是比较困难的，可以采用==递归==解决。下面给出解决【nSum】问题的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">nums: sorted之后的数组</span></span><br><span class="line"><span class="comment">start: 开始寻找的位置</span></span><br><span class="line"><span class="comment">k: 需要寻找多少个元素之和</span></span><br><span class="line"><span class="comment">target: 目标值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> k, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">2</span>)&#123; <span class="comment">// base case k ==</span></span><br><span class="line">        <span class="type">int</span> i = start; <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="type">int</span> left = nums[i]; <span class="type">int</span> right = nums[j];</span><br><span class="line">            <span class="type">int</span> sum = left + right;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                res.<span class="built_in">push</span>(&#123;left, right&#125;);</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == left) i++;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == right) j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == right) j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == left) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// other case k &gt; 2</span></span><br><span class="line">        <span class="type">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="type">int</span> val = nums[i];</span><br><span class="line">            <span class="type">int</span> sub_target = target - val;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sub_res = <span class="built_in">nSum</span>(nums, i+<span class="number">1</span>, k<span class="number">-1</span>, sub_target);</span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; sub_res_i : sub_res)&#123;</span><br><span class="line">                sub_res_i.<span class="built_in">push_back</span>(val);</span><br><span class="line">                res.<span class="built_in">push_back</span>(sub_res_i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; nums[i] == val) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间问题">2 区间问题</h2><blockquote><p>区间问题就是给定一些区间，然后需要求解这些区间的交集、或者合并区间等问题</p></blockquote><p>解决这类问题最核心的思想就是==排序==+==讨论==。</p><p>针对不同的问题，需要进行不同的排序，可能是对起点排序，也可能是对终点排序，有可能是升序，也有可能是降序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] != b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对nums进行排序，左端点升序排列，左端点相同右端点降序排列</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure><blockquote><p>题目列表：</p><p><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a></p><p><ahref="https://leetcode.cn/problems/non-overlapping-intervals/">435.无重叠区间</a></p><p><ahref="https://leetcode.cn/problems/remove-covered-intervals/">1288.删除被覆盖区间</a></p><p><a href="https://leetcode.cn/problems/merge-intervals/">56.合并区间</a></p><p><ahref="https://leetcode.cn/problems/interval-list-intersections/">986.区间列表的交集</a></p></blockquote><blockquote><p><a href="https://leetcode.cn/problems/video-stitching/">1024.视频拼接</a></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230105224256015.png" /></p></blockquote><p>一道别致的区间问题！这道题在对区间进行排序之后的操作更为复杂一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">videoStitching</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; clips, <span class="type">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(clips.<span class="built_in">begin</span>(), clips.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于是需要找出最少，所以就需要挑选出最合适的片段</span></span><br><span class="line">    <span class="type">int</span> n = clips.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 在后面有重叠的区间中找到终点最大的那个区间</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; clips[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (clips[i][<span class="number">1</span>] &gt; max) max = clips[i][<span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 中间有断开或者片段用完了但是没到time</span></span><br><span class="line">        end = max;</span><br><span class="line">        cnt ++;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= time) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择算法">3 快速选择算法</h2><blockquote><p><ahref="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215.数组中的第K个最大元素</a></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20221127115141557.png" /></p></blockquote><h3 id="快速排序算法">3.1 快速排序算法</h3><p>快排（quick-sort）是一种经典的排序算法，和归并排序（merge-sort）一样都是divide-and-conquer 类型的算法，平均时间复杂度为 <spanclass="math inline">\(O(NlogN)\)</span></p><p>【思路】</p><p>快排的思路是，要对<code>nums[lo...hi]</code>排序，先找到一个分界点<code>pivot</code>，然后使得<code>nums[lo...pivot-1]</code>都小于<code>nums[pivot]</code>，<code>nums[pivot+1...hi]</code>都大于<code>nums[pivot]</code>，然后递归地在<code>nums[lo...pivot-1]</code>和<code>nums[pivot+1...hi]</code>上执行相同的操作。</p><p>【实现过程】</p><p>首先可以轻易写出下面两个函数，最主要的难点是实现<code>partition</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort_helper</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, i, j);</span><br><span class="line">    <span class="built_in">quick_sort_helper</span>(nums, i, pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quick_sort_helper</span>(nums, pivot+<span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>partition</code>函数所做的工作就是，对一个数组<code>nums[lo...hi]</code>，返回一个下标<code>pivot</code>，使得数组<code>nums[lo...pivot-1]</code>部分的元素全部都小于<code>nums[pivot]</code>，数组<code>nums[pivot+1...hi]</code>部分的元素全部都大于<code>nums[pivot]</code>。</p><blockquote><ol type="1"><li>首先任意选取一个值作为pivot，比如选择最后一个元素`</li><li><code>smaller_idx</code>变量是用来记录所有<code>&lt;=nums[pivot]</code>的元素的下标</li><li>遍历数组，当遇到<code>&lt;=nums[pivot]</code>的元素时，就要把它放在<code>smaller_idx</code>指定的位置上（for循环中if块中的内容）</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = nums[hi];</span><br><span class="line">    <span class="type">int</span> smaller_idx = lo<span class="number">-1</span>; <span class="comment">// 标记&lt;=nums[pivot]元素的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = lo; i &lt;= hi; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= pivot)&#123;</span><br><span class="line">            smaller_idx ++;</span><br><span class="line">            <span class="built_in">swap</span>(nums, smaller_idx, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smaller_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://www.geeksforgeeks.org/quick-sort/">quick-sort</a></p></blockquote><p>上面的<code>partition</code>函数返回的<code>pivot</code>其实就是数组的第<code>pivot</code>大元素，而问题需要的是第<code>k</code>大元素，所以可以借用【二分搜索】思想进行求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lo = <span class="number">0</span>; <span class="type">int</span> hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> idx = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(idx &gt; pi)&#123;</span><br><span class="line">            lo = pi+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx &lt; pi)&#123;</span><br><span class="line">            hi = pi<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[pi];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉堆">3.2 二叉堆</h3><p>这道题最简单的还是采用二叉堆（优先队列）的解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; pq; <span class="comment">// 采用小顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k)&#123;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red'><code>priority_queue</code>数据结构自定义比较如何书写？</font></p><p>1、首先优先队列默认情况下是使用less比较，即大顶堆（最大元素作为堆顶出现）。如果想要改成小顶堆，需要使用greater比较。</p><p>2、如果要自定义优先队列的比较，可以在一个<strong>结构体</strong>里==重载()运算符==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、或者可以重载复合数据类型的比较运算符（改变原本less和greater中比较运算符的含义）</p><p><font color='red'>sort函数中的自定义比较应该如何书写？</font></p><p>1、默认情况下按照升序对容器内元素进行排序。</p><p>2、一般情况下只要重写一个比较函数传入sort函数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(container.<span class="built_in">begin</span>(), container.<span class="built_in">end</span>(), cmp); <span class="comment">// container 是 vector&lt;vector&lt;int&gt;&gt;</span></span><br></pre></td></tr></table></figure><p><strong>但是如果要在类中使用，自定义的比较函数一定得是静态成员函数或者全局函数</strong></p><p>因为<code>std::sort</code>函数是全局的，不能依赖于只有创建实例后才能使用的普通成员函数</p></blockquote><h2 id="运算优先级分治算法">4 运算优先级：分治算法</h2><blockquote><p><ahref="https://leetcode.cn/problems/different-ways-to-add-parentheses/">241.为运算表达式设计优先级</a></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230104002637818.png" /></p></blockquote><p>使用递归思想解决问题，一定要从整体出发考虑问题的结构，而不能局限于某个细节。将大问题不断分解成规模更小的子问题，当规模小到一定程度时就可以轻易求解，然后再将小规模问题的答案合并，得到最终问题的结果，这就是分治的思想。</p><p>这道题也是一样，给定一个表达式字符串，要求出该表达式所有可能的结果。无论如何改变运算符优先级，或者说增加括号，本质上表达式的计算都可以回到【操作数1操作符操作数2】这种形式上，只是这个操作数可以又是一个表达式，以此来增加复杂度。</p><p>如何分解复杂度呢？可以选定一个操作符，然后递归处理两边的表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> n = expression.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = expression[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(i+<span class="number">1</span>, n - i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> op1 : left)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> op2 : right)&#123;</span><br><span class="line">                    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: res.<span class="built_in">push_back</span>(op1+op2); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: res.<span class="built_in">push_back</span>(op1-op2); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: res.<span class="built_in">push_back</span>(op1*op2); <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            val = <span class="number">10</span> * val + expression[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法">5 贪心算法</h2><blockquote><p><a href="https://leetcode.cn/problems/gas-station/">134.加油站</a></p><p><imgsrc="https://my-picture-repo.obs.cn-east-3.myhuaweicloud.com/my-blog-imgs/image-20230105224152317.png" /></p></blockquote><p>看到问题的一个反应就是把两个数组变成一个数组<code>diff</code>，<code>diff[i]</code>表示在<code>i</code>加油站加完油开到<code>i+1</code>加油站的油量变化。那么要找到那个点，应该尽可能的让车在刚开始一段时间油量尽可能多，这样才能保证最后可以走完一圈。可以将<code>diff</code>的值标在图上，连起来之后最低点的下一个点就应该是出发的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; diff; <span class="comment">// 从i加完油开到i+1剩下的油量</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> onediff = gas[i] - cost[i];</span><br><span class="line">        diff.<span class="built_in">push_back</span>(onediff);</span><br><span class="line">        sum += onediff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="type">int</span> min = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        total += diff[i];</span><br><span class="line">        <span class="keyword">if</span> (total &lt; min)&#123;</span><br><span class="line">            min = total;</span><br><span class="line">            res = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (res+<span class="number">1</span>)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换一个思路，这道题更为普遍的想法应该是用一个双重循环去枚举所有的情况。可以增加一个<code>trick</code>：<strong>当发现从<code>i</code>开到<code>j</code>不能到达时，那么<code>i</code>到<code>j</code>中间的任何一个点出发都行不通</strong>。这样就避免了很多重复的情况，复杂度可以达到线性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; diff; <span class="comment">// 从i加完油开到i+1剩下的油量</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> onediff = gas[i] - cost[i];</span><br><span class="line">        diff.<span class="built_in">push_back</span>(onediff);</span><br><span class="line">        sum += onediff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (diff[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> j = (i+<span class="number">1</span>)%n;</span><br><span class="line">        <span class="type">int</span> total = diff[i];</span><br><span class="line">        <span class="keyword">for</span> (; j != i; j = (j+<span class="number">1</span>)%n)&#123;</span><br><span class="line">            total += diff[j];</span><br><span class="line">            <span class="keyword">if</span>(total &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == i) <span class="keyword">return</span> i;</span><br><span class="line">        i = (j + n - <span class="number">1</span>) % n; <span class="comment">// trick</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算器">6 计算器</h2><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator/">224.基本计算器</a></p><p><a href="https://leetcode.cn/problems/basic-calculator-ii/">227.基本计算器 II</a></p></blockquote><p>给定一个字符串，包含数字、四则运算符、括号以及空格，要求计算该表达式的值</p><p>可以将这个问题进行分解，比如：如何将字符串中的数提取出来、如何处理四则运算以及如何处理括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="comment">// 处理字符串中的数字</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            val = <span class="number">10</span> * val + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理四则运算</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span> || i == n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: stk.<span class="built_in">push</span>(val); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: stk.<span class="built_in">push</span>(<span class="number">-1</span> * val); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: val = stk.<span class="built_in">top</span>() * val; stk.<span class="built_in">pop</span>(); stk.<span class="built_in">push</span>(val); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: val = stk.<span class="built_in">top</span>() / val; stk.<span class="built_in">pop</span>(); stk.<span class="built_in">push</span>(val); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            sign = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理括号</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(cnt != <span class="number">0</span>)&#123;</span><br><span class="line">                i ++;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) cnt ++;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) cnt --;</span><br><span class="line">            &#125;</span><br><span class="line">            val = <span class="built_in">calculate</span>(s.<span class="built_in">substr</span>(start, i - start)); <span class="comment">// 递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        res += stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">leetcode刷题笔记</category>
      
      
      <category domain="http://example.com/tags/leetcode/">leetcode</category>
      
      
      <comments>http://example.com/2022/11/19/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B011%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
